# Section 02.5: Core System Tools & Capabilities

This section defines the conceptual Genkit tools and other core capabilities that Roo's specialized modes will utilize to perform their tasks. Each tool definition includes its purpose, a conceptual Genkit schema (name, description, inputSchema, outputSchema), and high-level implementation notes.

These definitions serve as the specification for the actual tool implementation (which Roo will undertake via tasks in its Roadmap, such as T027 and T031 which involve processing research on Genkit and Node.js `fs` to refine these).

## 2.5.1 Tools for Gemini-based Roo Modes (Conceptual Genkit `ai.defineTool` Structure)

These tools are designed to be implemented as Genkit tools within Roo's primary Node.js/TypeScript environment, utilized by modes running on the Gemini 2.5 Flash Preview 20-5 model.

---
**Tool 1: `FileSystemAccessTool` (Version 1.1 - MCP Focused)**

1.  **Tool Name:** `fileSystemAccessTool`
2.  **Purpose:** To provide controlled access to read, write, and manage files and directories within specifically allowed project paths (primarily the UDM, logs, and temporary operational state directories). This tool will interact with a configured Model Context Protocol (MCP) server that has scoped file system permissions.
3.  **Genkit Tool Definition (Conceptual - to be implemented as a custom Genkit tool that uses an MCP Client):**
    *   **`name` (string):** `"fileSystemAccessTool"`
    *   **`description` (string):** "Interacts with a scoped MCP file system server to perform operations like reading files, writing files, listing directory contents, and creating directories within allowed project paths (e.g., UDM, logs, state). All paths are relative to a pre-configured project root for safety."
    *   **`inputSchema` (Zod Schema):**
        ```typescript
        // Conceptual Zod schema for input
        z.object({
          action: z.enum([
            "readFile", 
            "writeFile", 
            "listFiles", 
            "listDirectories", 
            "createDirectory", 
            "deleteFile", // Use with extreme caution, perhaps restricted by default
            "checkExists" 
          ]).describe("The file system action to perform."),
          filePath: z.string().describe("The path to the file or directory, relative to the project's UDM/operational root. Must be sanitized and validated against allowed paths."),
          content: z.string().optional().describe("Content to write for 'writeFile' action."),
          encoding: z.enum(["utf8", "base64"]).optional().default("utf8").describe("Encoding for readFile/writeFile."),
          recursive: z.boolean().optional().default(false).describe("For 'createDirectory', create parent directories if they don't exist. For 'listFiles', list recursively (use with depth limit)."),
          maxDepth: z.number().int().optional().default(1).describe("For recursive 'listFiles', max depth to scan.")
        })
        ```
    *   **`outputSchema` (Zod Schema):**
        ```typescript
        // Conceptual Zod schema for output
        z.object({
          actionPerformed: z.string().describe("Mirrors input action."),
          filePathTargeted: z.string().describe("The path that was targeted by the action."),
          status: z.enum(["SUCCESS", "ERROR_PATH_NOT_FOUND", "ERROR_PERMISSION_DENIED", "ERROR_INVALID_PATH", "ERROR_WRITE_FAILED", "ERROR_READ_FAILED", "ERROR_MCP_SERVER_UNAVAILABLE", "ERROR_UNKNOWN"])
            .describe("Status of the file system operation."),
          fileExists: z.boolean().optional().describe("Result for 'checkExists' action."),
          fileContent: z.string().nullable().optional().describe("Content of the file for 'readFile' action (null if error or not applicable)."),
          directoryContents: z.array(z.object({ name: z.string(), type: z.enum(["file", "directory"]) })).optional()
            .describe("List of files/directories for 'listFiles' or 'listDirectories' actions."),
          errorDetails: z.string().nullable().describe("Details if the status indicates an error. Null if no error.")
        })
        ```
4.  **High-Level Implementation Notes:**
    *   **MCP Client Integration:** This Genkit tool will internally use an `mcpClient` (e.g., `genkitx-mcp`) configured for a project-specific MCP file system server.
    *   **MCP Server Configuration:** The backing MCP server MUST be configured with strict `ALLOWED_DIRS` (e.g., `/docs/udm/`, `/logs/`, `/state/`, `/prompts/`) and use Node.js `fs` module best practices for security (path sanitization, validation against base dir using `path.resolve` and `startsWith(TRUSTED_BASE_DIR + path.sep)`) and robust error handling (passing specific `fs` error codes like ENOENT, EACCES). Details are informed by UDM Appendix `APP-NODEJS-FS-RESEARCH-V1`.
    *   **Path Validation:** The Genkit tool itself must also perform initial validation on `filePath` inputs before calling the MCP client.
    *   **Security:** `deleteFile` action requires extreme caution; consider disabling by default or requiring a special confirmation flag not yet in the schema.
    *   **UDM Configuration:** UDM Section `06-Operational-Config.md` will detail MCP server setup and client configuration.

---
**Tool 2: `WebSearchTool`**

1.  **Tool Name:** `webSearchTool`
2.  **Purpose:** To perform web searches using a search engine and return a list of relevant search results, including titles, snippets, and URLs.
3.  **Genkit Tool Definition (Conceptual):**
    *   **`name` (string):** `"webSearchTool"`
    *   **`description` (string):** "Performs a web search using a designated search engine based on a query. Returns a list of search results including titles, URLs, and descriptive snippets."
    *   **`inputSchema` (Zod Schema):**
        ```typescript
        z.object({
          query: z.string().describe("The search query string."),
          numResults: z.number().int().positive().optional().default(5).describe("Optional. Number of search results to return. Default: 5.")
        })
        ```
    *   **`outputSchema` (Zod Schema):**
        ```typescript
        z.object({
          searchQueryExecuted: z.string().describe("The actual query string executed."),
          results: z.array(
            z.object({
              title: z.string().describe("Title of the search result."),
              link: z.string().url().describe("URL of the search result."),
              snippet: z.string().describe("Descriptive snippet from the result.")
            })
          ).describe("List of search results."),
          errorDetails: z.string().nullable().describe("Details if the search failed. Null if no error.")
        })
        ```
4.  **High-Level Implementation Notes:**
    *   **API Backend:** Likely uses Google Custom Search API or similar.
    *   **API Key Management:** Requires secure API key handling (UDM Section 06).
    *   **Error Handling:** Must handle API errors, rate limits, no results.
    *   **Query Formulation:** The calling mode (e.g., `ROO-MODE-RESEARCH`) is responsible for effective query formulation.

---
**Tool 3: `DocumentFetchingParsingTool` (Version 1.1 - Revised Output)**

1.  **Tool Name:** `documentFetchingParsingTool`
2.  **Purpose:** To fetch content from a given URL (e.g., HTML webpage, PDF document online, plain text file) and parse it into a structured textual representation, optionally extracting specific sections or metadata.
3.  **Genkit Tool Definition (Conceptual):**
    *   **`name` (string):** `"documentFetchingParsingTool"`
    *   **`description` (string):** "Fetches content from a provided URL and parses it into a clean textual format. Can handle common web page formats (HTML) and attempt to extract text from PDFs or other document types. Optionally, can try to extract specific sections if selectors or keywords are provided."
    *   **`inputSchema` (Zod Schema):**
        ```typescript
        z.object({
          url: z.string().url().describe("The fully qualified URL of the document to fetch and parse."),
          documentTypeHint: z.enum(["html", "pdf", "txt", "auto"]).optional().default("auto").describe("Optional. A hint about the document type to aid parsing. 'auto' will attempt to infer from content type or URL extension."),
          maxLengthBytes: z.number().int().positive().optional().default(1000000) // 1MB default limit 
            .describe("Optional. Maximum content length in bytes to process to prevent overload. Tool should truncate or error if exceeded.")
        })
        ```
    *   **`outputSchema` (Zod Schema - Version 1.1 with mandatory metadata/errorDetails):**
        ```typescript
        z.object({
          fetchedUrl: z.string().url().describe("The URL from which content was fetched."),
          status: z.enum(["SUCCESS", "PARTIAL_SUCCESS", "ERROR_FETCH", "ERROR_PARSE", "ERROR_TOO_LARGE", "ERROR_UNSUPPORTED_TYPE"])
            .describe("Status of the fetching and parsing operation."),
          contentTypeDetected: z.string().optional().describe("The detected MIME type of the content. May not be present if fetch failed early."),
          title: z.string().optional().describe("The title of the document, if found (e.g., from HTML <title> tag)."),
          cleanedTextContent: z.string().nullable().describe("The primary extracted and cleaned textual content. Null if no text could be extracted. May be truncated if it exceeded maxLengthBytes and partial extraction was possible."),
          metadata: z.record(z.string(), z.any()).describe("Other extracted metadata (e.g., author, publication date). Will be an empty object if no specific metadata is extracted."),
          errorDetails: z.string().nullable().describe("Details if the status indicates an error. Null if no error.")
        })
        ```
4.  **High-Level Implementation Notes:**
    *   **Fetching:** Use robust HTTP client (e.g., `node-fetch`), handle errors, respect `robots.txt` (for ethical considerations).
    *   **Parsing:** Use appropriate libraries for HTML (e.g., Cheerio, JSDOM with Readability), PDF (e.g., PDF.js, pdf-parse), TXT.
    *   **Content Cleaning:** Standardize whitespace, line breaks.
    *   **`maxLengthBytes`:** Enforce this limit to prevent overload.
    *   **Error Handling:** Populate `status` and `errorDetails` accurately.

---
**Tool 4: `Context7DocumentationTool`**

1.  **Tool Name:** `context7DocumentationTool`
2.  **Purpose:** To interact with a Context7 MCP Server to resolve library names to Context7-compatible IDs and fetch specific documentation for those libraries.
3.  **Genkit Tool Definition (Conceptual):**
    *   **`name` (string):** `"context7DocumentationTool"`
    *   **`description` (string):** "Queries a Context7 MCP Server to find Context7-compatible IDs for given library names and then fetches documentation for those libraries. Can optionally focus on specific topics and request max tokens."
    *   **`inputSchema` (Zod Schema):**
        ```typescript
        z.object({
          action: z.enum(["resolve_library_id", "get_library_docs"])
            .describe("Action: resolve library name to ID, or get documentation for a known ID."),
          libraryName: z.string().optional()
            .describe("Common name of the library (e.g., 'Next.js'). Required for 'resolve_library_id'."),
          context7CompatibleLibraryID: z.string().optional()
            .describe("Exact Context7 ID (e.g., '/vercel/next.js'). Required for 'get_library_docs'."),
          topic: z.string().optional()
            .describe("Optional. Focus docs on a specific topic (e.g., 'routing')."),
          maxTokens: z.number().int().positive().optional().default(10000)
            .describe("Optional. Max tokens for returned docs. Default: 10000. Server may have own minimums.")
        })
        ```
    *   **`outputSchema` (Zod Schema):**
        ```typescript
        z.object({
          actionPerformed: z.enum(["resolve_library_id", "get_library_docs"]),
          status: z.enum(["SUCCESS", "ERROR_MCP_CONNECTION", "ERROR_LIBRARY_NOT_FOUND", "ERROR_DOCS_NOT_FOUND", "ERROR_INVALID_INPUT"])
            .describe("Status of the Context7 MCP interaction."),
          libraryNameQueried: z.string().optional(),
          resolvedLibraryID: z.string().optional()
            .describe("Context7 ID found, if action was 'resolve_library_id' and SUCCESS."),
          context7LibraryIDQueried: z.string().optional(),
          documentationTopic: z.string().optional(),
          retrievedDocumentation: z.string().nullable()
            .describe("Fetched documentation content (e.g., Markdown). Null if no docs or error."),
          errorDetails: z.string().nullable().describe("Error details. Null if no error.")
        })
        ```
4.  **High-Level Implementation Notes:**
    *   **MCP Server Interaction:** Uses an `mcpClient` to connect to a configured Context7 MCP Server (local or remote).
    *   **Two-Step Process:** Typically `resolve_library_id` then `get_library_docs`.
    *   **Error Handling:** Manage connection errors, library/docs not found, invalid inputs from MCP server.
    *   **Configuration:** Context7 MCP server URL/command in UDM Section 06.

---
**Tool 5: `UDMQueryTool` (Conceptual)**

1.  **Tool Name:** `udmQueryTool`
2.  **Purpose:** To allow me to query specific, structured information from the UDM itself. This is essential for me to access my own "constitution" and operational data without needing to parse entire large UDM files for every small piece of information.
3.  **Genkit Tool Definition (Conceptual):**
    *   **`name` (string):** `"udmQueryTool"`
    *   **`description` (string):** "Queries the Unified Development Manual (UDM) for specific information. Can fetch content from sections, specific task definitions, tool definitions, configuration parameters, etc., based on UDM paths or unique IDs."
    *   **`inputSchema` (Zod Schema):**
        ```typescript
        z.object({
          query_type: z.enum([
            "get_section_content",
            "get_task_definition",
            "get_mode_definition",
            "get_tool_definition",
            "get_config_value",
            "find_by_id" // Generic find by unique ID across UDM structures
          ]).describe("The type of query to perform on the UDM."),
          udm_path_or_id: z.string().describe("The UDM file path and optionally a section header/anchor (e.g., '/docs/udm/05-Roadmap-Lifecycle.md#TASK-P0-M0.1-T001') or a unique ID (e.g., 'TASK-P0-M0.1-T001', 'RM-001', 'COMP-002')."),
          // specific_keys: z.array(z.string()).optional().describe("For structured data (like task defs), specific keys to retrieve.")
        })
        ```
    *   **`outputSchema` (Zod Schema):**
        ```typescript
        z.object({
          queryPerformed: z.string().describe("A confirmation of the query path or ID used."),
          status: z.enum(["SUCCESS", "ERROR_PATH_NOT_FOUND", "ERROR_ID_NOT_FOUND", "ERROR_PARSING_UDM_SECTION", "ERROR_AMBIGUOUS_QUERY"])
            .describe("Status of the UDM query operation."),
          retrievedContent: z.any().nullable() // Could be string (Markdown section), object (parsed YAML/JSON from task/mode def)
            .describe("The content retrieved from the UDM. Structure depends on query_type. Null if not found or error."),
          errorDetails: z.string().nullable().describe("Details if the status indicates an error. Null if no error.")
        })
        ```
4.  **High-Level Implementation Notes:**
    *   **UDM Indexing/Parsing:** This tool implies a robust backend capability for me to have an indexed or easily parsable representation of my entire UDM.
    *   **Path & ID Resolution:** Needs logic to resolve UDM paths and unique IDs to specific file locations and content blocks.
    *   **Content Extraction:** For "get_section_content", it would extract Markdown. For "get_task_definition" etc., it would parse the relevant UDM file (e.g., `05-Roadmap-Lifecycle.md`) and extract the structured data for that specific task ID, returning it as a JSON object.
    *   **Security/Scope:** Implicitly operates only on files within the UDM's defined directory structure.

---
**Tool 6: `MarkdownParserEditorTool` (Conceptual - used by `ROO-MODE-UPDATE-UDM-TECHNICAL`)**

1.  **Tool Name:** `markdownParserEditorTool`
2.  **Purpose:** To perform in-memory Abstract Syntax Tree (AST) based parsing, manipulation (finding sections by header, replacing content, appending content), and re-serialization of Markdown text.
3.  **Genkit Tool Definition (Conceptual):**
    *   **`name` (string):** `"markdownParserEditorTool"`
    *   **`description` (string):** "Parses Markdown text into an AST, allows targeted modifications to the AST (e.g., replacing a section identified by its header), and serializes the AST back to a Markdown string. For UDM content manipulation."
    *   **`inputSchema` (Zod Schema):** (Highly complex to define generically; would likely take specific modification instructions and the Markdown text). Example for a "replaceSection" action:
        ```typescript
        z.object({
          markdownContent: z.string(),
          action: z.literal("replaceSection"),
          sectionHeader: z.string().describe("The exact header text of the section to replace."),
          newSectionContent: z.string().describe("The new Markdown content for that section.")
        })
        ```
    *   **`outputSchema` (Zod Schema):**
        ```typescript
        z.object({
          modifiedMarkdownContent: z.string().nullable(),
          status: z.enum(["SUCCESS", "ERROR_SECTION_NOT_FOUND", "ERROR_PARSING", "ERROR_SERIALIZING"]),
          errorDetails: z.string().nullable()
        })
        ```
4.  **High-Level Implementation Notes:**
    *   **Underlying Library:** Recommended to use the `unified/remark` ecosystem as per UDM Appendix `APP-PARSING-LIBS-RESEARCH-V1`.
    *   **Operations:** Would need to implement specific sub-actions for finding nodes, replacing nodes, appending nodes, etc., based on common UDM update needs. This tool is more of an internal capability for `ROO-MODE-UPDATE-UDM-TECHNICAL`'s LLM to leverage when it reasons about how to apply an update from its `udm_updates_list`.

---
**Tool 7: `YamlJsonParserEditorTool` (Conceptual - used by `ROO-MODE-UPDATE-UDM-TECHNICAL`)**

1.  **Tool Name:** `yamlJsonParserEditorTool`
2.  **Purpose:** To perform in-memory parsing, manipulation (modifying key-value pairs), and re-serialization of YAML or JSON data, with a strong focus on preserving comments and formatting for YAML.
3.  **Genkit Tool Definition (Conceptual):**
    *   **`name` (string):** `"yamlJsonParserEditorTool"`
    *   **`description` (string):** "Parses YAML or JSON text into a data structure, allows targeted modifications (e.g., updating a key's value), and serializes the structure back to text, preserving YAML comments. For UDM content manipulation."
    *   **`inputSchema` (Zod Schema):** (Example for a "modifyKeyValue" action)
        ```typescript
        z.object({
          textContent: z.string(),
          format: z.enum(["yaml", "json", "json5"]),
          action: z.literal("modifyKeyValue"),
          keyPath: z.string().describe("Dot-separated path to the key (e.g., 'server.port')."),
          newValue: z.any().describe("The new value for the key.")
        })
        ```
    *   **`outputSchema` (Zod Schema):**
        ```typescript
        z.object({
          modifiedTextContent: z.string().nullable(),
          status: z.enum(["SUCCESS", "ERROR_KEY_NOT_FOUND", "ERROR_PARSING", "ERROR_SERIALIZING"]),
          errorDetails: z.string().nullable()
        })
        ```
4.  **High-Level Implementation Notes:**
    *   **Underlying Library:** Recommended to use `yaml` (by Eemeli Aaro) for YAML to ensure comment preservation, and native `JSON` or `JSON5` for JSON, as per UDM Appendix `APP-PARSING-LIBS-RESEARCH-V1`.
    *   **Operations:** Similar to the Markdown tool, this represents an internal capability for `ROO-MODE-UPDATE-UDM-TECHNICAL`.

---
## 2.5.X Browser Action Tool Suite (for Claude API Tool-Use)

These tools are designed to be called by the Claude Sonnet 3.5 model when I am operating in `ClaudeBrowserMode`. I am responsible for executing the underlying browser automation (e.g., via Puppeteer or Playwright, informed by Roocode browser specifics if applicable) when Claude requests one of these tools via the Anthropic Messages API `tool_use` mechanism. Their definitions here specify the `name`, `description`, and `input_schema` (JSON Schema format) that will be provided to the Claude API. The *output* of these tools (e.g., screenshot path, console log, status) is processed by me and sent back to Claude as a `tool_result`.

### Browser Action Tool Suite (for Claude API Tool-Use)

These tools are designed to be called by the Claude Sonnet 3.5 model when I am operating in `ClaudeBrowserMode`. I am responsible for executing the underlying browser automation (e.g., via Puppeteer or Playwright, informed by Roocode browser specifics if applicable) when Claude requests one of these tools via the Anthropic Messages API `tool_use` mechanism. Their definitions here specify the `name`, `description`, and `input_schema` (JSON Schema format) that will be provided to the Claude API. The *output* of these tools (e.g., screenshot path, console log, status) is processed by me and sent back to Claude as a `tool_result`.

---
**Tool 8: `launchBrowser`**

1.  **Tool Name:** `launchBrowser`
2.  **Purpose:** Launches a new browser session or tab and navigates to the specified URL. This should typically be the first action in a new browser session. Returns the initial page's title and a screenshot.
3.  **Genkit Tool Definition (Conceptual - for Claude API):**
    *   **`name` (string):** `"launchBrowser"`
    *   **`description` (string):** "Launches a new browser session or tab and navigates to the specified URL. This should typically be the first action in a new browser session. Returns the initial page's title and a screenshot."
    *   **`inputSchema` (JSON Schema):**
        ```json
        {
          "type": "object",
          "properties": {
            "url": { "type": "string", "description": "URL to navigate to." },
            "viewport_width": { "type": "integer", "optional": true },
            "viewport_height": { "type": "integer", "optional": true }
          },
          "required": ["url"]
        }
        ```
    *   **High-Level Implementation Notes:** Uses Puppeteer/Playwright. Handles initial page load, screenshot capture.

---
**Tool 9: `clickElement`**

1.  **Tool Name:** `clickElement`
2.  **Purpose:** Clicks on a web page element specified by a CSS selector or XPath. Specify only one selector type.
3.  **Genkit Tool Definition (Conceptual - for Claude API):**
    *   **`name` (string):** `"clickElement"`
    *   **`description` (string):** "Clicks on a web page element specified by a CSS selector or XPath. Specify only one selector type."
    *   **`inputSchema` (JSON Schema):**
        ```json
        {
          "type": "object",
          "properties": {
            "selector_type": { "type": "string", "enum": ["css", "xpath"] },
            "selector_value": { "type": "string" },
            "wait_for_navigation_timeout_ms": { "type": "integer", "optional": true, "default": 5000 }
          },
          "required": ["selector_type", "selector_value"]
        }
        ```
    *   **High-Level Implementation Notes:** Uses Puppeteer/Playwright. Handles element finding, clicking, and optional navigation waiting.

---
**Tool 10: `typeText`**

1.  **Tool Name:** `typeText`
2.  **Purpose:** Types text into a specified input element identified by a CSS selector or XPath.
3.  **Genkit Tool Definition (Conceptual - for Claude API):**
    *   **`name` (string):** `"typeText"`
    *   **`description` (string):** "Types text into a specified input element identified by a CSS selector or XPath."
    *   **`inputSchema` (JSON Schema):**
        ```json
        {
          "type": "object",
          "properties": {
            "selector_type": { "type": "string", "enum": ["css", "xpath"] },
            "selector_value": { "type": "string" },
            "text_to_type": { "type": "string" },
            "clear_before_type": { "type": "boolean", "default": true, "optional": true },
            "submit_after_type": { "type": "boolean", "default": false, "optional": true }
          },
          "required": ["selector_type", "selector_value", "text_to_type"]
        }
        ```
    *   **High-Level Implementation Notes:** Uses Puppeteer/Playwright. Handles text input, optional clearing and submission.

---
**Tool 11: `scrollPage`**

1.  **Tool Name:** `scrollPage`
2.  **Purpose:** Scrolls the current page up/down by page units or to a specific element.
3.  **Genkit Tool Definition (Conceptual - for Claude API):**
    *   **`name` (string):** `"scrollPage"`
    *   **`description` (string):** "Scrolls the current page up/down by page units or to a specific element."
    *   **`inputSchema` (JSON Schema):**
        ```json
        {
          "type": "object",
          "properties": {
            "direction": { "type": "string", "enum": ["up", "down", "to_element"], "default": "down" },
            "pages": { "type": "integer", "default": 1, "optional": true },
            "selector_type": { "type": "string", "enum": ["css", "xpath"], "optional": true },
            "selector_value": { "type": "string", "optional": true }
          }
        }
        ```
    *   **High-Level Implementation Notes:** Uses Puppeteer/Playwright. Handles scrolling logic.

---
**Tool 12: `captureScreenshot`**

1.  **Tool Name:** `captureScreenshot`
2.  **Purpose:** Captures a screenshot of the current viewport, full page, or a specific element.
3.  **Genkit Tool Definition (Conceptual - for Claude API):**
    *   **`name` (string):** `"captureScreenshot"`
    *   **`description` (string):** "Captures a screenshot of the current viewport, full page, or a specific element."
    *   **`inputSchema` (JSON Schema):**
        ```json
        {
          "type": "object",
          "properties": {
            "capture_type": { "type": "string", "enum": ["full_page", "viewport", "element"], "default": "viewport" },
            "selector_type": { "type": "string", "enum": ["css", "xpath"], "optional": true },
            "selector_value": { "type": "string", "optional": true },
            "image_format": { "type": "string", "enum": ["png", "jpeg"], "default": "png", "optional": true },
            "quality": { "type": "integer", "default": 75, "optional": true }
          }
        }
        ```
    *   **High-Level Implementation Notes:** Uses Puppeteer/Playwright. Handles various screenshot types and formats.

---
**Tool 13: `getElementText`**

1.  **Tool Name:** `getElementText`
2.  **Purpose:** Extracts text content from an element specified by a CSS selector or XPath.
3.  **Genkit Tool Definition (Conceptual - for Claude API):**
    *   **`name` (string):** `"getElementText"`
    *   **`description` (string):** "Extracts text content from an element specified by a CSS selector or XPath."
    *   **`inputSchema` (JSON Schema):**
        ```json
        {
          "type": "object",
          "properties": {
            "selector_type": { "type": "string", "enum": ["css", "xpath"] },
            "selector_value": { "type": "string" }
          },
          "required": ["selector_type", "selector_value"]
        }
        ```
    *   **High-Level Implementation Notes:** Uses Puppeteer/Playwright. Extracts text content.

---
**Tool 14: `checkElementExists`**

1.  **Tool Name:** `checkElementExists`
2.  **Purpose:** Checks if an element specified by a CSS selector or XPath exists.
3.  **Genkit Tool Definition (Conceptual - for Claude API):**
    *   **`name` (string):** `"checkElementExists"`
    *   **`description` (string):** "Checks if an element specified by a CSS selector or XPath exists."
    *   **`inputSchema` (JSON Schema):**
        ```json
        {
          "type": "object",
          "properties": {
            "selector_type": { "type": "string", "enum": ["css", "xpath"] },
            "selector_value": { "type": "string" }
          },
          "required": ["selector_type", "selector_value"]
        }
        ```
    *   **High-Level Implementation Notes:** Uses Puppeteer/Playwright. Checks for element presence.

---
**Tool 15: `closeBrowser`**

1.  **Tool Name:** `closeBrowser`
2.  **Purpose:** Closes the current browser session. Should be the final action if the goal is complete.
3.  **Genkit Tool Definition (Conceptual - for Claude API):**
    *   **`name` (string):** `"closeBrowser"`
    *   **`description` (string):** "Closes the current browser session. Should be the final action if the goal is complete."
    *   **`inputSchema` (JSON Schema):**
        ```json
        {
          "type": "object",
          "properties": {},
          "additionalProperties": false
        }
        ```
    *   **High-Level Implementation Notes:** Uses Puppeteer/Playwright. Closes the browser instance.

---